一.问题分析
	A.https://blog.csdn.net/weixin_42882439/article/details/82869490
		1.ArrayList和LinkedList的区别
			原理分别是C语言的数组和链表
			LinkedList插入操作，LinkedList链表的结构更高效，原因是可以通过修改节点的指针 就可以完成插入操作，查询时需要获取下个节点的地址然后获取值，所以效率低
			ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的），但是插入和删除需要移动数据，所以效率低
		2.ArrayList与Vector的区别
			Vector的方法都是同步的，是线程安全的
			ArrayList是异步的，线程同步必然影响性能，ArrayList性能较好
			当Vector或ArrayList中的元素超过它的初始大小时，Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样。ArrayList就有利于节约内存空间。
			如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。比如ArrayList和Vector都默认初始化1024字节  但是你需要更大的数组存放数据你可以修改Vector的初始大小为3*1024，之后就不用扩展数组内存，你需要的内存越大，Vector越有优势。
		3.HashSet与TreeSet的区别
			TreeSet 是二叉树实现的，Treeset中的数据是自动排好序的，不允许放入null值,不能重复 。
			HashSet 底层用的是HashMap 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，不能重复，就如数据库中唯一约束 。
			HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类不同的实例可以放入。
二.数据结构
	1.哈希表
		也叫散列表 把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。实际是一种通过key在数组中找值的方式，牺牲空间换取效率
		数组和向量都可以存储对象，但对象的存储位置是随机的，也就是说对象本身与其存储位置之间没有必然的联系。当要查找一个对象时，只能以某种顺序（如顺序查找或二分查找）与各个元素进行比较，当数组或向量中的元素数量很多时，查找的效率会明显的降低。一种有效的存储方式，是不与其他元素进行比较，一次存取便能得到所需要的记录。这就需要在对象的存储位置和对象的关键属性（设为 k）之间建立一个特定的对应关系（设为 f），使每个对象与一个唯一的存储位置相对应。在查找时，只要根据待查对象的关键属性 k 计算f(k)的值即可。如果此对象在集合中，则必定在存储位置 f(k)上，因此不需要与集合中的其他元素进行比较。称这种对应关系 f 为哈希（hash）方法，按照这种思想建立的表为哈希表。
		key-value
		a.创建数组,长度为m
		b.将key通过固定算法函数转成整型数字k(哈希值)
		c.k%m结果作为数组的下标存储value
		假设哈希表的地址集为，冲突是指由关键字得到的哈希地址为的位置上已存有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。?
		在处理冲突的过程中可能得到一个地址序列。即在处理哈希地址的冲突时，若得到的另一个哈希地址仍然发生冲突，则再求下一个地址，若仍然冲突，再求，依次类推，直至不发生冲突为止，则为记录在表中的地址。?